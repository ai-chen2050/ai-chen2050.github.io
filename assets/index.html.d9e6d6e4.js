import{_ as e,o as r,c as a,a as o}from"./app.df6d7c29.js";var t="/img/in-post/2024-07/Prolly-tree-overview.png",i="/img/in-post/2024-07/Hyper-logical-clock-algo.png";const n={},s=o('<p>Some implements of novelty logical clock + CRDTs for data consistency in distributed p2p applications.</p><h2 id="overview" tabindex="-1"><a class="header-anchor" href="#overview" aria-hidden="true">#</a> Overview</h2><p>The documents will discuss <strong>logical clock</strong>\u3001<strong>crdt</strong> (<a href="https://crdt.tech/" target="_blank" rel="noopener noreferrer">Conflict-free Replicated Data Type</a>)\u3001and core data structures: Merkle-DAG of <strong>Merkle-CRDTs</strong>, <strong>Prolly-tree</strong> of Canvas, and <strong>HLC</strong> (hybrid logical clock).</p><p>So, if confused about those concepts, you can read the appendix reference for details.</p><h2 id="core-concepts" tabindex="-1"><a class="header-anchor" href="#core-concepts" aria-hidden="true">#</a> Core concepts</h2><h3 id="merkle-crdts" tabindex="-1"><a class="header-anchor" href="#merkle-crdts" aria-hidden="true">#</a> Merkle-CRDTs</h3><h4 id="background" tabindex="-1"><a class="header-anchor" href="#background" aria-hidden="true">#</a> Background</h4><p>Merkle-CRDTs come from <code>Merkle-DAGs meet CRDTs</code> <a href="https://arxiv.org/pdf/2004.00107" target="_blank" rel="noopener noreferrer">paper</a> by Protocol Labs and IPFS/FileCoin community. It was early used to sync KV data in a conflict-free way between IPFS cluster nodes. Now, <a href="https://ipfscluster.io/documentation/guides/consensus/" target="_blank" rel="noopener noreferrer">ipfscluster</a> still supports two consensus components, CRDT(default) and Raft.</p><p>As time passed, the followers utilized Merkle-CRDTs to keep consistency in distributed p2p database applications. Likes, <a href="https://github.com/orbitdb/orbitdb" target="_blank" rel="noopener noreferrer">orbitDB</a>\u3001<a href="https://source.network/defra-db" target="_blank" rel="noopener noreferrer">defraDB</a> of source network.</p><h4 id="major-innovation" tabindex="-1"><a class="header-anchor" href="#major-innovation" aria-hidden="true">#</a> Major innovation</h4><p>As we all know, the first logical clock is the Lamport clock, and the versioned clock and vector clock are as follows. In the Merkle-CRDTs context, the paper formalized defines Merkle-Clocks and proves it contains casualty ordering and other features of logical logic.</p><p>The Merkle-DAG is built by merging other DAGs in other replicas. New events are added as new root nodes (parents to the existing ones). Note that the Merkle-Clock may have several roots at a given time. Thus, Merkle-DAGs are not only ever-growing but also tend to be deep and thin.</p><h4 id="pros-and-cons" tabindex="-1"><a class="header-anchor" href="#pros-and-cons" aria-hidden="true">#</a> pros and cons</h4><p><strong>PROS</strong> :</p><ul><li>Merkle-Clocks decouple the causality information from the number of replicas. vs. to vector clock.</li><li>Merkle DAG is <strong>content-addressed</strong> and <strong>self-authenticating</strong>, so can tolerate dropped messages and network-disturbed.</li></ul><p><strong>CONS</strong></p><ul><li>Ever-growing DAG-Size, Very large DAGs, and initial slow syncs</li><li>Merkle-Clock sorting and merge may be a costly operation.</li></ul><p>So when thinking about adopting Merkle-CRDTs, users should consider whether Merkle-CRDTs are the best approach in terms of:</p><ul><li>i) Node count vs. state-size,</li><li>ii) Time to cold-sync,</li><li>iii) Update propagation latency,</li><li>iv) Expected total number of replicas,</li><li>v) Expected replica-set modifications (joins and departures),</li><li>vi) Expected volume of concurrent events.</li></ul><h3 id="canvas-prolly-tree" tabindex="-1"><a class="header-anchor" href="#canvas-prolly-tree" aria-hidden="true">#</a> Canvas &amp; Prolly Tree</h3><h4 id="background-1" tabindex="-1"><a class="header-anchor" href="#background-1" aria-hidden="true">#</a> Background</h4><p>Canvas is a runtime for distributed TypeScript applications. It utilizes IPFS stacks to fill the goals, etc, IPLD, LibP2P, Gossip-pub/sub, and logger.</p><ul><li>Core Components: <ul><li><a href="https://github.com/canvasxyz/okra" target="_blank" rel="noopener noreferrer">Okra</a><ul><li>A p2p-optimized <strong>Prolly</strong> tree that allows <strong>fast sync</strong> between ordered sets of actions.</li></ul></li><li><a href="https://github.com/canvasxyz/canvas/tree/main/packages/gossiplog" target="_blank" rel="noopener noreferrer">Gossiplog</a><ul><li>A self-authenticating causal log for multi-writer applications.</li><li>LibP2P + Lamport clock to implement CRDT.</li></ul></li><li>ModelDB - A cross-platform relational database <strong>wrapper</strong>, supporting IndexedDB and SQLite.</li></ul></li></ul><h4 id="major-innovation-1" tabindex="-1"><a class="header-anchor" href="#major-innovation-1" aria-hidden="true">#</a> Major innovation</h4><p>P2P-optimized <a href="https://docs.canvas.xyz/blog/2023-05-04-merklizing-the-key-value-store.html#conclusions" target="_blank" rel="noopener noreferrer">Prolly</a> tree, just is used to fast sync between ordered sets of actions. Actually, Prolly looks more like a\xA0<a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener noreferrer">skip list</a>\xA0than a tree:</p><p><img src="'+t+'" alt="Prolly-tree-overview.png"></p><h4 id="pros-and-cons-1" tabindex="-1"><a class="header-anchor" href="#pros-and-cons-1" aria-hidden="true">#</a> pros and cons</h4><ul><li>Pros <ul><li>The GossipLog embeds the Lamport clock to a unique message ID to fulfill CRDT.</li><li>Using use the Prolly tree as the KV-DB index to fast sync is the more <strong>lightweight</strong> way.</li></ul></li><li>Cons <ul><li>Compared with orbitDB, it is relatively new and need more time to battle-scarred.</li></ul></li></ul><h3 id="hlc" tabindex="-1"><a class="header-anchor" href="#hlc" aria-hidden="true">#</a> HLC</h3><p>Logical Physical Clocks proposes a hybrid logical clock, that combines the best of logical clocks and physical clocks.</p><p>HLC captures the causality relationship like logical clocks and enables easy identification of consistent snapshots in distributed systems. It fits into 64-bit NTP timestamp format and embeds physical time to the Logical clock.</p><p><img src="'+i+'" alt="Hyper-logical-clock-algo.png"></p><h2 id="conclusions" tabindex="-1"><a class="header-anchor" href="#conclusions" aria-hidden="true">#</a> Conclusions</h2><p>At this stage, we first refer to orbitDB, which implements Merkle-CRDTs, and canvas project, which implements Prolly Tree.</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><ul><li><a href="https://arxiv.org/pdf/2004.00107" target="_blank" rel="noopener noreferrer">Merkle-CRDTs</a></li><li><a href="https://docs.canvas.xyz/blog/2023-05-04-merklizing-the-key-value-store.html#conclusions" target="_blank" rel="noopener noreferrer">Prolly-tree </a></li><li><a href="https://cse.buffalo.edu/~demirbas/publications/hlc.pdf" target="_blank" rel="noopener noreferrer">Hybrid logical clock</a></li><li><a href="https://crdt.tech/" target="_blank" rel="noopener noreferrer">crdt.tech</a></li></ul>',36),l=[s];function c(d,h){return r(),a("div",null,l)}var u=e(n,[["render",c],["__file","index.html.vue"]]);export{u as default};
