import{_ as e,o as a,c as o,a as i}from"./app.640d6444.js";var c="/img/in-post/2024-05-20/Untitled.png",t="/img/in-post/2024-05-20/Untitled1.png",s="/img/in-post/2024-05-20/Untitled2.png",r="/img/in-post/2024-05-20/Untitled3.png";const l={},n=i('<p>Verifiable logic clock &amp; vlc and its use cases.</p><h2 id="vlc-and-its-use-cases-and-application-brief-description" tabindex="-1"><a class="header-anchor" href="#vlc-and-its-use-cases-and-application-brief-description" aria-hidden="true">#</a> vlc and its use cases and application brief description</h2><h2 id="prerequisites" tabindex="-1"><a class="header-anchor" href="#prerequisites" aria-hidden="true">#</a> Prerequisites</h2><h3 id="lamport-clock" tabindex="-1"><a class="header-anchor" href="#lamport-clock" aria-hidden="true">#</a> <strong>Lamport clock</strong></h3><p>The Lamport clock is a logical clock used to <code>order events</code> in a distributed system. It provides a way to capture the &quot;<code>happens-before</code>&quot; relationship between events, which is essential for understanding <code>causality</code>.</p><p><img src="'+c+'" alt="Untitled"></p><h4 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h4><p>Consider two processes, P1 and P2:</p><ul><li>P1 starts with a clock value of 1, performs an event (clock becomes 2), and sends a message to P2 with the timestamp 2.</li><li>P2 receives the message with timestamp 2, and updates its clock to <code>max(current clock, 2) + 1</code> (e.g., if P2&#39;s current clock was 1, it becomes 3).</li></ul><h4 id="conclusions" tabindex="-1"><a class="header-anchor" href="#conclusions" aria-hidden="true">#</a> Conclusions</h4><ul><li><code>Cannot capture concurrent events</code> (events that are not causally related). <ul><li>As shown in the above picture, <code>events a and b</code></li></ul></li><li>It constructs <code>fail to work</code> in an open network with <code>Byzantine participants</code>.</li></ul><h3 id="vector-clock" tabindex="-1"><a class="header-anchor" href="#vector-clock" aria-hidden="true">#</a> <strong>Vector clock</strong></h3><p>Vector clocks are an <code>extension of Lamport clocks</code> that provide more detailed information about the causality of events. Each process <code>maintains a vector of clock values</code>, one for each process in the system.</p><p><img src="'+t+'" alt="Untitled"></p><h4 id="examples-1" tabindex="-1"><a class="header-anchor" href="#examples-1" aria-hidden="true">#</a> Examples</h4><p>Consider two processes, P1 and P2:</p><ul><li>P1&#39;s vector clock is initially\xA0<code>[0, 0]</code>. It performs an event, updating to\xA0<code>[1, 0]</code>, and sends a message to P2.</li><li>P2&#39;s vector clock is\xA0<code>[0, 0]</code>. Upon receiving the message with vector clock\xA0<code>[1, 0]</code>, it updates to\xA0<code>[1, 1]</code>\xA0(assuming it performs an event after receiving).</li></ul><h4 id="conclusions-1" tabindex="-1"><a class="header-anchor" href="#conclusions-1" aria-hidden="true">#</a> Conclusions</h4><ul><li>It constructs <code>fail to work</code> in an open network with <code>Byzantine participants</code>.</li></ul><h2 id="vlc-verifiable-logical-clock" tabindex="-1"><a class="header-anchor" href="#vlc-verifiable-logical-clock" aria-hidden="true">#</a> VLC (Verifiable Logical Clock)</h2><p>Without reliable logical clocks, systems and applications <code>are forced to use expensive BFT SMR</code> protocols which <code>enforces total order</code> of requests, <code>even though</code> their application semantics may <code>only require partial ordering</code> guarantees.</p><h3 id="chrono-overview" tabindex="-1"><a class="header-anchor" href="#chrono-overview" aria-hidden="true">#</a> Chrono overview</h3><p>So, vlc (verifiable logical clock) is construct atop on vector clock, and add the verifiable proof feature. The chrono is as a concrete instance of VLC. More detail could read the paper of <a href="https://arxiv.org/pdf/2405.13349" target="_blank" rel="noopener noreferrer"><code>Building a Verifiable Logical Clock for P2P Networks</code></a></p><p><img src="'+s+'" alt="Untitled"></p><h3 id="validator-backends" tabindex="-1"><a class="header-anchor" href="#validator-backends" aria-hidden="true">#</a> Validator backends</h3><p><img src="'+r+'" alt="Untitled"></p><h2 id="applications-use-cases" tabindex="-1"><a class="header-anchor" href="#applications-use-cases" aria-hidden="true">#</a> Applications &amp; use cases</h2><p>Two use cases, <code>causally Consistent Data Store</code> and <code>mutual exclusion</code>, are introduced in detail in <a href="https://arxiv.org/pdf/2405.13349" target="_blank" rel="noopener noreferrer">paper</a>.</p><h3 id="regular-logical-clock-use-case" tabindex="-1"><a class="header-anchor" href="#regular-logical-clock-use-case" aria-hidden="true">#</a> Regular logical clock use case</h3><p>Regular logical clock have been applied in many scenarios. As follows:</p><ul><li>Weakly consistent storage systems <ul><li>(<code>Cops: causally Consistent Data Store</code>)</li></ul></li><li>Causally ordered broadcast <ul><li>( <a href="https://www.notion.so/vlc-p2p-combined-draft-483b5cbfd96d4c829e0368afc742fc38?pvs=21" target="_blank" rel="noopener noreferrer">Reference: vlc + p2p combined</a> )</li></ul></li><li>Deadlock detection <ul><li>(<code>Mutual exclusion</code> of shared resources in a distributed system)</li><li>Bakery algorithm</li></ul></li><li>Distributed snapshots</li><li>Distributed system debugging.</li></ul><h3 id="vlc-implement-s-use-cases" tabindex="-1"><a class="header-anchor" href="#vlc-implement-s-use-cases" aria-hidden="true">#</a> VLC implement\u2019s use cases</h3><ul><li><code>Cops: causally Consistent Data Store</code></li><li><code>Mutual exclusion</code></li></ul>',33),d=[n];function h(p,u){return a(),o("div",null,d)}var m=e(l,[["render",h],["__file","index.html.vue"]]);export{m as default};
